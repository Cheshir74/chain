// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bc.proto

#ifndef PROTOBUF_bc_2eproto__INCLUDED
#define PROTOBUF_bc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace bc {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_bc_2eproto();
void protobuf_AssignDesc_bc_2eproto();
void protobuf_ShutdownFile_bc_2eproto();

class AssetAmount;
class AssetDefinition;
class AssetID;
class BlockHeader;
class Coinbase;
class Hash;
class Issuance;
class Mux;
class Nonce;
class Output;
class Program;
class Retirement;
class Spend;
class TransactionStatus;
class TxHeader;
class ValueDestination;
class ValueSource;

// ===================================================================

class Hash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Hash) */ {
 public:
  Hash();
  virtual ~Hash();

  Hash(const Hash& from);

  inline Hash& operator=(const Hash& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hash& default_instance();

  void Swap(Hash* other);

  // implements Message ----------------------------------------------

  inline Hash* New() const { return New(NULL); }

  Hash* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hash& from);
  void MergeFrom(const Hash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Hash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 v0 = 1;
  void clear_v0();
  static const int kV0FieldNumber = 1;
  ::google::protobuf::uint64 v0() const;
  void set_v0(::google::protobuf::uint64 value);

  // optional fixed64 v1 = 2;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  ::google::protobuf::uint64 v1() const;
  void set_v1(::google::protobuf::uint64 value);

  // optional fixed64 v2 = 3;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  ::google::protobuf::uint64 v2() const;
  void set_v2(::google::protobuf::uint64 value);

  // optional fixed64 v3 = 4;
  void clear_v3();
  static const int kV3FieldNumber = 4;
  ::google::protobuf::uint64 v3() const;
  void set_v3(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Hash)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 v0_;
  ::google::protobuf::uint64 v1_;
  ::google::protobuf::uint64 v2_;
  ::google::protobuf::uint64 v3_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Hash* default_instance_;
};
// -------------------------------------------------------------------

class Program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();

  void Swap(Program* other);

  // implements Message ----------------------------------------------

  inline Program* New() const { return New(NULL); }

  Program* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 vm_version = 1;
  void clear_vm_version();
  static const int kVmVersionFieldNumber = 1;
  ::google::protobuf::uint64 vm_version() const;
  void set_vm_version(::google::protobuf::uint64 value);

  // optional bytes code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const void* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:bc.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 vm_version_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Program* default_instance_;
};
// -------------------------------------------------------------------

class AssetID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetID) */ {
 public:
  AssetID();
  virtual ~AssetID();

  AssetID(const AssetID& from);

  inline AssetID& operator=(const AssetID& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetID& default_instance();

  void Swap(AssetID* other);

  // implements Message ----------------------------------------------

  inline AssetID* New() const { return New(NULL); }

  AssetID* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetID& from);
  void MergeFrom(const AssetID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 v0 = 1;
  void clear_v0();
  static const int kV0FieldNumber = 1;
  ::google::protobuf::uint64 v0() const;
  void set_v0(::google::protobuf::uint64 value);

  // optional fixed64 v1 = 2;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  ::google::protobuf::uint64 v1() const;
  void set_v1(::google::protobuf::uint64 value);

  // optional fixed64 v2 = 3;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  ::google::protobuf::uint64 v2() const;
  void set_v2(::google::protobuf::uint64 value);

  // optional fixed64 v3 = 4;
  void clear_v3();
  static const int kV3FieldNumber = 4;
  ::google::protobuf::uint64 v3() const;
  void set_v3(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.AssetID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 v0_;
  ::google::protobuf::uint64 v1_;
  ::google::protobuf::uint64 v2_;
  ::google::protobuf::uint64 v3_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static AssetID* default_instance_;
};
// -------------------------------------------------------------------

class AssetAmount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetAmount) */ {
 public:
  AssetAmount();
  virtual ~AssetAmount();

  AssetAmount(const AssetAmount& from);

  inline AssetAmount& operator=(const AssetAmount& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetAmount& default_instance();

  void Swap(AssetAmount* other);

  // implements Message ----------------------------------------------

  inline AssetAmount* New() const { return New(NULL); }

  AssetAmount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetAmount& from);
  void MergeFrom(const AssetAmount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetAmount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.AssetID asset_id = 1;
  bool has_asset_id() const;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 1;
  const ::bc::AssetID& asset_id() const;
  ::bc::AssetID* mutable_asset_id();
  ::bc::AssetID* release_asset_id();
  void set_allocated_asset_id(::bc::AssetID* asset_id);

  // optional uint64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.AssetAmount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::AssetID* asset_id_;
  ::google::protobuf::uint64 amount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static AssetAmount* default_instance_;
};
// -------------------------------------------------------------------

class AssetDefinition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetDefinition) */ {
 public:
  AssetDefinition();
  virtual ~AssetDefinition();

  AssetDefinition(const AssetDefinition& from);

  inline AssetDefinition& operator=(const AssetDefinition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetDefinition& default_instance();

  void Swap(AssetDefinition* other);

  // implements Message ----------------------------------------------

  inline AssetDefinition* New() const { return New(NULL); }

  AssetDefinition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetDefinition& from);
  void MergeFrom(const AssetDefinition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssetDefinition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Hash initial_block_id = 1;
  bool has_initial_block_id() const;
  void clear_initial_block_id();
  static const int kInitialBlockIdFieldNumber = 1;
  const ::bc::Hash& initial_block_id() const;
  ::bc::Hash* mutable_initial_block_id();
  ::bc::Hash* release_initial_block_id();
  void set_allocated_initial_block_id(::bc::Hash* initial_block_id);

  // optional .bc.Program issuance_program = 2;
  bool has_issuance_program() const;
  void clear_issuance_program();
  static const int kIssuanceProgramFieldNumber = 2;
  const ::bc::Program& issuance_program() const;
  ::bc::Program* mutable_issuance_program();
  ::bc::Program* release_issuance_program();
  void set_allocated_issuance_program(::bc::Program* issuance_program);

  // optional .bc.Hash data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // @@protoc_insertion_point(class_scope:bc.AssetDefinition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Hash* initial_block_id_;
  ::bc::Program* issuance_program_;
  ::bc::Hash* data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static AssetDefinition* default_instance_;
};
// -------------------------------------------------------------------

class ValueSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.ValueSource) */ {
 public:
  ValueSource();
  virtual ~ValueSource();

  ValueSource(const ValueSource& from);

  inline ValueSource& operator=(const ValueSource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueSource& default_instance();

  void Swap(ValueSource* other);

  // implements Message ----------------------------------------------

  inline ValueSource* New() const { return New(NULL); }

  ValueSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValueSource& from);
  void MergeFrom(const ValueSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Hash ref = 1;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 1;
  const ::bc::Hash& ref() const;
  ::bc::Hash* mutable_ref();
  ::bc::Hash* release_ref();
  void set_allocated_ref(::bc::Hash* ref);

  // optional .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* mutable_value();
  ::bc::AssetAmount* release_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // optional uint64 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint64 position() const;
  void set_position(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.ValueSource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Hash* ref_;
  ::bc::AssetAmount* value_;
  ::google::protobuf::uint64 position_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static ValueSource* default_instance_;
};
// -------------------------------------------------------------------

class ValueDestination : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.ValueDestination) */ {
 public:
  ValueDestination();
  virtual ~ValueDestination();

  ValueDestination(const ValueDestination& from);

  inline ValueDestination& operator=(const ValueDestination& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueDestination& default_instance();

  void Swap(ValueDestination* other);

  // implements Message ----------------------------------------------

  inline ValueDestination* New() const { return New(NULL); }

  ValueDestination* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValueDestination& from);
  void MergeFrom(const ValueDestination& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueDestination* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Hash ref = 1;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 1;
  const ::bc::Hash& ref() const;
  ::bc::Hash* mutable_ref();
  ::bc::Hash* release_ref();
  void set_allocated_ref(::bc::Hash* ref);

  // optional .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* mutable_value();
  ::bc::AssetAmount* release_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // optional uint64 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint64 position() const;
  void set_position(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.ValueDestination)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Hash* ref_;
  ::bc::AssetAmount* value_;
  ::google::protobuf::uint64 position_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static ValueDestination* default_instance_;
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  void Swap(BlockHeader* other);

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const { return New(NULL); }

  BlockHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // optional uint64 serialized_size = 2;
  void clear_serialized_size();
  static const int kSerializedSizeFieldNumber = 2;
  ::google::protobuf::uint64 serialized_size() const;
  void set_serialized_size(::google::protobuf::uint64 value);

  // optional uint64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // optional .bc.Hash previous_block_id = 4;
  bool has_previous_block_id() const;
  void clear_previous_block_id();
  static const int kPreviousBlockIdFieldNumber = 4;
  const ::bc::Hash& previous_block_id() const;
  ::bc::Hash* mutable_previous_block_id();
  ::bc::Hash* release_previous_block_id();
  void set_allocated_previous_block_id(::bc::Hash* previous_block_id);

  // optional .bc.Hash seed = 5;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 5;
  const ::bc::Hash& seed() const;
  ::bc::Hash* mutable_seed();
  ::bc::Hash* release_seed();
  void set_allocated_seed(::bc::Hash* seed);

  // optional uint64 timestamp = 6;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .bc.Hash transactions_root = 7;
  bool has_transactions_root() const;
  void clear_transactions_root();
  static const int kTransactionsRootFieldNumber = 7;
  const ::bc::Hash& transactions_root() const;
  ::bc::Hash* mutable_transactions_root();
  ::bc::Hash* release_transactions_root();
  void set_allocated_transactions_root(::bc::Hash* transactions_root);

  // optional .bc.Hash assets_root = 8;
  bool has_assets_root() const;
  void clear_assets_root();
  static const int kAssetsRootFieldNumber = 8;
  const ::bc::Hash& assets_root() const;
  ::bc::Hash* mutable_assets_root();
  ::bc::Hash* release_assets_root();
  void set_allocated_assets_root(::bc::Hash* assets_root);

  // optional .bc.TransactionStatus transaction_status = 9;
  bool has_transaction_status() const;
  void clear_transaction_status();
  static const int kTransactionStatusFieldNumber = 9;
  const ::bc::TransactionStatus& transaction_status() const;
  ::bc::TransactionStatus* mutable_transaction_status();
  ::bc::TransactionStatus* release_transaction_status();
  void set_allocated_transaction_status(::bc::TransactionStatus* transaction_status);

  // optional uint64 nonce = 10;
  void clear_nonce();
  static const int kNonceFieldNumber = 10;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // optional uint64 bits = 11;
  void clear_bits();
  static const int kBitsFieldNumber = 11;
  ::google::protobuf::uint64 bits() const;
  void set_bits(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.BlockHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 serialized_size_;
  ::google::protobuf::uint64 height_;
  ::bc::Hash* previous_block_id_;
  ::bc::Hash* seed_;
  ::google::protobuf::uint64 timestamp_;
  ::bc::Hash* transactions_root_;
  ::bc::Hash* assets_root_;
  ::bc::TransactionStatus* transaction_status_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::uint64 bits_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static BlockHeader* default_instance_;
};
// -------------------------------------------------------------------

class TxHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.TxHeader) */ {
 public:
  TxHeader();
  virtual ~TxHeader();

  TxHeader(const TxHeader& from);

  inline TxHeader& operator=(const TxHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxHeader& default_instance();

  void Swap(TxHeader* other);

  // implements Message ----------------------------------------------

  inline TxHeader* New() const { return New(NULL); }

  TxHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxHeader& from);
  void MergeFrom(const TxHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // optional uint64 serialized_size = 2;
  void clear_serialized_size();
  static const int kSerializedSizeFieldNumber = 2;
  ::google::protobuf::uint64 serialized_size() const;
  void set_serialized_size(::google::protobuf::uint64 value);

  // optional uint64 time_range = 3;
  void clear_time_range();
  static const int kTimeRangeFieldNumber = 3;
  ::google::protobuf::uint64 time_range() const;
  void set_time_range(::google::protobuf::uint64 value);

  // repeated .bc.Hash result_ids = 4;
  int result_ids_size() const;
  void clear_result_ids();
  static const int kResultIdsFieldNumber = 4;
  const ::bc::Hash& result_ids(int index) const;
  ::bc::Hash* mutable_result_ids(int index);
  ::bc::Hash* add_result_ids();
  ::google::protobuf::RepeatedPtrField< ::bc::Hash >*
      mutable_result_ids();
  const ::google::protobuf::RepeatedPtrField< ::bc::Hash >&
      result_ids() const;

  // optional .bc.Hash data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // optional .bc.Hash ext_hash = 6;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 6;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // @@protoc_insertion_point(class_scope:bc.TxHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 serialized_size_;
  ::google::protobuf::uint64 time_range_;
  ::google::protobuf::RepeatedPtrField< ::bc::Hash > result_ids_;
  ::bc::Hash* data_;
  ::bc::Hash* ext_hash_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static TxHeader* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.TransactionStatus) */ {
 public:
  TransactionStatus();
  virtual ~TransactionStatus();

  TransactionStatus(const TransactionStatus& from);

  inline TransactionStatus& operator=(const TransactionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionStatus& default_instance();

  void Swap(TransactionStatus* other);

  // implements Message ----------------------------------------------

  inline TransactionStatus* New() const { return New(NULL); }

  TransactionStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionStatus& from);
  void MergeFrom(const TransactionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransactionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes bitmap = 1;
  void clear_bitmap();
  static const int kBitmapFieldNumber = 1;
  const ::std::string& bitmap() const;
  void set_bitmap(const ::std::string& value);
  void set_bitmap(const char* value);
  void set_bitmap(const void* value, size_t size);
  ::std::string* mutable_bitmap();
  ::std::string* release_bitmap();
  void set_allocated_bitmap(::std::string* bitmap);

  // @@protoc_insertion_point(class_scope:bc.TransactionStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr bitmap_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static TransactionStatus* default_instance_;
};
// -------------------------------------------------------------------

class Mux : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Mux) */ {
 public:
  Mux();
  virtual ~Mux();

  Mux(const Mux& from);

  inline Mux& operator=(const Mux& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mux& default_instance();

  void Swap(Mux* other);

  // implements Message ----------------------------------------------

  inline Mux* New() const { return New(NULL); }

  Mux* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mux& from);
  void MergeFrom(const Mux& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mux* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bc.ValueSource sources = 1;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 1;
  const ::bc::ValueSource& sources(int index) const;
  ::bc::ValueSource* mutable_sources(int index);
  ::bc::ValueSource* add_sources();
  ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >*
      mutable_sources();
  const ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >&
      sources() const;

  // optional .bc.Program program = 2;
  bool has_program() const;
  void clear_program();
  static const int kProgramFieldNumber = 2;
  const ::bc::Program& program() const;
  ::bc::Program* mutable_program();
  ::bc::Program* release_program();
  void set_allocated_program(::bc::Program* program);

  // optional .bc.Hash ext_hash = 3;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 3;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // repeated .bc.ValueDestination witness_destinations = 4;
  int witness_destinations_size() const;
  void clear_witness_destinations();
  static const int kWitnessDestinationsFieldNumber = 4;
  const ::bc::ValueDestination& witness_destinations(int index) const;
  ::bc::ValueDestination* mutable_witness_destinations(int index);
  ::bc::ValueDestination* add_witness_destinations();
  ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >*
      mutable_witness_destinations();
  const ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >&
      witness_destinations() const;

  // repeated bytes witness_arguments = 5;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 5;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // @@protoc_insertion_point(class_scope:bc.Mux)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::bc::ValueSource > sources_;
  ::bc::Program* program_;
  ::bc::Hash* ext_hash_;
  ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination > witness_destinations_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Mux* default_instance_;
};
// -------------------------------------------------------------------

class Nonce : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Nonce) */ {
 public:
  Nonce();
  virtual ~Nonce();

  Nonce(const Nonce& from);

  inline Nonce& operator=(const Nonce& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nonce& default_instance();

  void Swap(Nonce* other);

  // implements Message ----------------------------------------------

  inline Nonce* New() const { return New(NULL); }

  Nonce* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nonce& from);
  void MergeFrom(const Nonce& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Nonce* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Program program = 1;
  bool has_program() const;
  void clear_program();
  static const int kProgramFieldNumber = 1;
  const ::bc::Program& program() const;
  ::bc::Program* mutable_program();
  ::bc::Program* release_program();
  void set_allocated_program(::bc::Program* program);

  // optional .bc.Hash ext_hash = 2;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 2;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // repeated bytes witness_arguments = 3;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 3;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // optional .bc.Hash witness_anchored_id = 4;
  bool has_witness_anchored_id() const;
  void clear_witness_anchored_id();
  static const int kWitnessAnchoredIdFieldNumber = 4;
  const ::bc::Hash& witness_anchored_id() const;
  ::bc::Hash* mutable_witness_anchored_id();
  ::bc::Hash* release_witness_anchored_id();
  void set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id);

  // @@protoc_insertion_point(class_scope:bc.Nonce)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Program* program_;
  ::bc::Hash* ext_hash_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Hash* witness_anchored_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Nonce* default_instance_;
};
// -------------------------------------------------------------------

class Coinbase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Coinbase) */ {
 public:
  Coinbase();
  virtual ~Coinbase();

  Coinbase(const Coinbase& from);

  inline Coinbase& operator=(const Coinbase& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coinbase& default_instance();

  void Swap(Coinbase* other);

  // implements Message ----------------------------------------------

  inline Coinbase* New() const { return New(NULL); }

  Coinbase* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coinbase& from);
  void MergeFrom(const Coinbase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Coinbase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.ValueDestination witness_destination = 1;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 1;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* mutable_witness_destination();
  ::bc::ValueDestination* release_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // optional bytes arbitrary = 2;
  void clear_arbitrary();
  static const int kArbitraryFieldNumber = 2;
  const ::std::string& arbitrary() const;
  void set_arbitrary(const ::std::string& value);
  void set_arbitrary(const char* value);
  void set_arbitrary(const void* value, size_t size);
  ::std::string* mutable_arbitrary();
  ::std::string* release_arbitrary();
  void set_allocated_arbitrary(::std::string* arbitrary);

  // @@protoc_insertion_point(class_scope:bc.Coinbase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::ValueDestination* witness_destination_;
  ::google::protobuf::internal::ArenaStringPtr arbitrary_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Coinbase* default_instance_;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  void Swap(Output* other);

  // implements Message ----------------------------------------------

  inline Output* New() const { return New(NULL); }

  Output* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.ValueSource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::bc::ValueSource& source() const;
  ::bc::ValueSource* mutable_source();
  ::bc::ValueSource* release_source();
  void set_allocated_source(::bc::ValueSource* source);

  // optional .bc.Program control_program = 2;
  bool has_control_program() const;
  void clear_control_program();
  static const int kControlProgramFieldNumber = 2;
  const ::bc::Program& control_program() const;
  ::bc::Program* mutable_control_program();
  ::bc::Program* release_control_program();
  void set_allocated_control_program(::bc::Program* control_program);

  // optional .bc.Hash data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // optional .bc.Hash ext_hash = 4;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 4;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // optional uint64 ordinal = 5;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 5;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::ValueSource* source_;
  ::bc::Program* control_program_;
  ::bc::Hash* data_;
  ::bc::Hash* ext_hash_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Output* default_instance_;
};
// -------------------------------------------------------------------

class Retirement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Retirement) */ {
 public:
  Retirement();
  virtual ~Retirement();

  Retirement(const Retirement& from);

  inline Retirement& operator=(const Retirement& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Retirement& default_instance();

  void Swap(Retirement* other);

  // implements Message ----------------------------------------------

  inline Retirement* New() const { return New(NULL); }

  Retirement* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Retirement& from);
  void MergeFrom(const Retirement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Retirement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.ValueSource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::bc::ValueSource& source() const;
  ::bc::ValueSource* mutable_source();
  ::bc::ValueSource* release_source();
  void set_allocated_source(::bc::ValueSource* source);

  // optional .bc.Hash data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // optional .bc.Hash ext_hash = 3;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 3;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // optional uint64 ordinal = 4;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 4;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Retirement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::ValueSource* source_;
  ::bc::Hash* data_;
  ::bc::Hash* ext_hash_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Retirement* default_instance_;
};
// -------------------------------------------------------------------

class Issuance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Issuance) */ {
 public:
  Issuance();
  virtual ~Issuance();

  Issuance(const Issuance& from);

  inline Issuance& operator=(const Issuance& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Issuance& default_instance();

  void Swap(Issuance* other);

  // implements Message ----------------------------------------------

  inline Issuance* New() const { return New(NULL); }

  Issuance* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Issuance& from);
  void MergeFrom(const Issuance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Issuance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Hash anchor_id = 1;
  bool has_anchor_id() const;
  void clear_anchor_id();
  static const int kAnchorIdFieldNumber = 1;
  const ::bc::Hash& anchor_id() const;
  ::bc::Hash* mutable_anchor_id();
  ::bc::Hash* release_anchor_id();
  void set_allocated_anchor_id(::bc::Hash* anchor_id);

  // optional .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* mutable_value();
  ::bc::AssetAmount* release_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // optional .bc.Hash data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // optional .bc.Hash ext_hash = 4;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 4;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // optional .bc.ValueDestination witness_destination = 5;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 5;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* mutable_witness_destination();
  ::bc::ValueDestination* release_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // optional .bc.AssetDefinition witness_asset_definition = 6;
  bool has_witness_asset_definition() const;
  void clear_witness_asset_definition();
  static const int kWitnessAssetDefinitionFieldNumber = 6;
  const ::bc::AssetDefinition& witness_asset_definition() const;
  ::bc::AssetDefinition* mutable_witness_asset_definition();
  ::bc::AssetDefinition* release_witness_asset_definition();
  void set_allocated_witness_asset_definition(::bc::AssetDefinition* witness_asset_definition);

  // repeated bytes witness_arguments = 7;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 7;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // optional .bc.Hash witness_anchored_id = 8;
  bool has_witness_anchored_id() const;
  void clear_witness_anchored_id();
  static const int kWitnessAnchoredIdFieldNumber = 8;
  const ::bc::Hash& witness_anchored_id() const;
  ::bc::Hash* mutable_witness_anchored_id();
  ::bc::Hash* release_witness_anchored_id();
  void set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id);

  // optional uint64 ordinal = 9;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 9;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Issuance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Hash* anchor_id_;
  ::bc::AssetAmount* value_;
  ::bc::Hash* data_;
  ::bc::Hash* ext_hash_;
  ::bc::ValueDestination* witness_destination_;
  ::bc::AssetDefinition* witness_asset_definition_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Hash* witness_anchored_id_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Issuance* default_instance_;
};
// -------------------------------------------------------------------

class Spend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Spend) */ {
 public:
  Spend();
  virtual ~Spend();

  Spend(const Spend& from);

  inline Spend& operator=(const Spend& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Spend& default_instance();

  void Swap(Spend* other);

  // implements Message ----------------------------------------------

  inline Spend* New() const { return New(NULL); }

  Spend* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Spend& from);
  void MergeFrom(const Spend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Spend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bc.Hash spent_output_id = 1;
  bool has_spent_output_id() const;
  void clear_spent_output_id();
  static const int kSpentOutputIdFieldNumber = 1;
  const ::bc::Hash& spent_output_id() const;
  ::bc::Hash* mutable_spent_output_id();
  ::bc::Hash* release_spent_output_id();
  void set_allocated_spent_output_id(::bc::Hash* spent_output_id);

  // optional .bc.Hash data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::bc::Hash& data() const;
  ::bc::Hash* mutable_data();
  ::bc::Hash* release_data();
  void set_allocated_data(::bc::Hash* data);

  // optional .bc.Hash ext_hash = 3;
  bool has_ext_hash() const;
  void clear_ext_hash();
  static const int kExtHashFieldNumber = 3;
  const ::bc::Hash& ext_hash() const;
  ::bc::Hash* mutable_ext_hash();
  ::bc::Hash* release_ext_hash();
  void set_allocated_ext_hash(::bc::Hash* ext_hash);

  // optional .bc.ValueDestination witness_destination = 4;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 4;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* mutable_witness_destination();
  ::bc::ValueDestination* release_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // repeated bytes witness_arguments = 5;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 5;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // optional .bc.Hash witness_anchored_id = 6;
  bool has_witness_anchored_id() const;
  void clear_witness_anchored_id();
  static const int kWitnessAnchoredIdFieldNumber = 6;
  const ::bc::Hash& witness_anchored_id() const;
  ::bc::Hash* mutable_witness_anchored_id();
  ::bc::Hash* release_witness_anchored_id();
  void set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id);

  // optional uint64 ordinal = 7;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 7;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Spend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::bc::Hash* spent_output_id_;
  ::bc::Hash* data_;
  ::bc::Hash* ext_hash_;
  ::bc::ValueDestination* witness_destination_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Hash* witness_anchored_id_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bc_2eproto();
  friend void protobuf_AssignDesc_bc_2eproto();
  friend void protobuf_ShutdownFile_bc_2eproto();

  void InitAsDefaultInstance();
  static Spend* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Hash

// optional fixed64 v0 = 1;
inline void Hash::clear_v0() {
  v0_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v0() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v0)
  return v0_;
}
inline void Hash::set_v0(::google::protobuf::uint64 value) {
  
  v0_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v0)
}

// optional fixed64 v1 = 2;
inline void Hash::clear_v1() {
  v1_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v1() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v1)
  return v1_;
}
inline void Hash::set_v1(::google::protobuf::uint64 value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v1)
}

// optional fixed64 v2 = 3;
inline void Hash::clear_v2() {
  v2_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v2() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v2)
  return v2_;
}
inline void Hash::set_v2(::google::protobuf::uint64 value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v2)
}

// optional fixed64 v3 = 4;
inline void Hash::clear_v3() {
  v3_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v3() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v3)
  return v3_;
}
inline void Hash::set_v3(::google::protobuf::uint64 value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v3)
}

// -------------------------------------------------------------------

// Program

// optional uint64 vm_version = 1;
inline void Program::clear_vm_version() {
  vm_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Program::vm_version() const {
  // @@protoc_insertion_point(field_get:bc.Program.vm_version)
  return vm_version_;
}
inline void Program::set_vm_version(::google::protobuf::uint64 value) {
  
  vm_version_ = value;
  // @@protoc_insertion_point(field_set:bc.Program.vm_version)
}

// optional bytes code = 2;
inline void Program::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::code() const {
  // @@protoc_insertion_point(field_get:bc.Program.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bc.Program.code)
}
inline void Program::set_code(const char* value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bc.Program.code)
}
inline void Program::set_code(const void* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bc.Program.code)
}
inline ::std::string* Program::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:bc.Program.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_code() {
  // @@protoc_insertion_point(field_release:bc.Program.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:bc.Program.code)
}

// -------------------------------------------------------------------

// AssetID

// optional fixed64 v0 = 1;
inline void AssetID::clear_v0() {
  v0_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v0() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v0)
  return v0_;
}
inline void AssetID::set_v0(::google::protobuf::uint64 value) {
  
  v0_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v0)
}

// optional fixed64 v1 = 2;
inline void AssetID::clear_v1() {
  v1_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v1() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v1)
  return v1_;
}
inline void AssetID::set_v1(::google::protobuf::uint64 value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v1)
}

// optional fixed64 v2 = 3;
inline void AssetID::clear_v2() {
  v2_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v2() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v2)
  return v2_;
}
inline void AssetID::set_v2(::google::protobuf::uint64 value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v2)
}

// optional fixed64 v3 = 4;
inline void AssetID::clear_v3() {
  v3_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v3() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v3)
  return v3_;
}
inline void AssetID::set_v3(::google::protobuf::uint64 value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v3)
}

// -------------------------------------------------------------------

// AssetAmount

// optional .bc.AssetID asset_id = 1;
inline bool AssetAmount::has_asset_id() const {
  return !_is_default_instance_ && asset_id_ != NULL;
}
inline void AssetAmount::clear_asset_id() {
  if (GetArenaNoVirtual() == NULL && asset_id_ != NULL) delete asset_id_;
  asset_id_ = NULL;
}
inline const ::bc::AssetID& AssetAmount::asset_id() const {
  // @@protoc_insertion_point(field_get:bc.AssetAmount.asset_id)
  return asset_id_ != NULL ? *asset_id_ : *default_instance_->asset_id_;
}
inline ::bc::AssetID* AssetAmount::mutable_asset_id() {
  
  if (asset_id_ == NULL) {
    asset_id_ = new ::bc::AssetID;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetAmount.asset_id)
  return asset_id_;
}
inline ::bc::AssetID* AssetAmount::release_asset_id() {
  // @@protoc_insertion_point(field_release:bc.AssetAmount.asset_id)
  
  ::bc::AssetID* temp = asset_id_;
  asset_id_ = NULL;
  return temp;
}
inline void AssetAmount::set_allocated_asset_id(::bc::AssetID* asset_id) {
  delete asset_id_;
  asset_id_ = asset_id;
  if (asset_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.AssetAmount.asset_id)
}

// optional uint64 amount = 2;
inline void AssetAmount::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetAmount::amount() const {
  // @@protoc_insertion_point(field_get:bc.AssetAmount.amount)
  return amount_;
}
inline void AssetAmount::set_amount(::google::protobuf::uint64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetAmount.amount)
}

// -------------------------------------------------------------------

// AssetDefinition

// optional .bc.Hash initial_block_id = 1;
inline bool AssetDefinition::has_initial_block_id() const {
  return !_is_default_instance_ && initial_block_id_ != NULL;
}
inline void AssetDefinition::clear_initial_block_id() {
  if (GetArenaNoVirtual() == NULL && initial_block_id_ != NULL) delete initial_block_id_;
  initial_block_id_ = NULL;
}
inline const ::bc::Hash& AssetDefinition::initial_block_id() const {
  // @@protoc_insertion_point(field_get:bc.AssetDefinition.initial_block_id)
  return initial_block_id_ != NULL ? *initial_block_id_ : *default_instance_->initial_block_id_;
}
inline ::bc::Hash* AssetDefinition::mutable_initial_block_id() {
  
  if (initial_block_id_ == NULL) {
    initial_block_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetDefinition.initial_block_id)
  return initial_block_id_;
}
inline ::bc::Hash* AssetDefinition::release_initial_block_id() {
  // @@protoc_insertion_point(field_release:bc.AssetDefinition.initial_block_id)
  
  ::bc::Hash* temp = initial_block_id_;
  initial_block_id_ = NULL;
  return temp;
}
inline void AssetDefinition::set_allocated_initial_block_id(::bc::Hash* initial_block_id) {
  delete initial_block_id_;
  initial_block_id_ = initial_block_id;
  if (initial_block_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.AssetDefinition.initial_block_id)
}

// optional .bc.Program issuance_program = 2;
inline bool AssetDefinition::has_issuance_program() const {
  return !_is_default_instance_ && issuance_program_ != NULL;
}
inline void AssetDefinition::clear_issuance_program() {
  if (GetArenaNoVirtual() == NULL && issuance_program_ != NULL) delete issuance_program_;
  issuance_program_ = NULL;
}
inline const ::bc::Program& AssetDefinition::issuance_program() const {
  // @@protoc_insertion_point(field_get:bc.AssetDefinition.issuance_program)
  return issuance_program_ != NULL ? *issuance_program_ : *default_instance_->issuance_program_;
}
inline ::bc::Program* AssetDefinition::mutable_issuance_program() {
  
  if (issuance_program_ == NULL) {
    issuance_program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetDefinition.issuance_program)
  return issuance_program_;
}
inline ::bc::Program* AssetDefinition::release_issuance_program() {
  // @@protoc_insertion_point(field_release:bc.AssetDefinition.issuance_program)
  
  ::bc::Program* temp = issuance_program_;
  issuance_program_ = NULL;
  return temp;
}
inline void AssetDefinition::set_allocated_issuance_program(::bc::Program* issuance_program) {
  delete issuance_program_;
  issuance_program_ = issuance_program;
  if (issuance_program) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.AssetDefinition.issuance_program)
}

// optional .bc.Hash data = 3;
inline bool AssetDefinition::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void AssetDefinition::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& AssetDefinition::data() const {
  // @@protoc_insertion_point(field_get:bc.AssetDefinition.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* AssetDefinition::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetDefinition.data)
  return data_;
}
inline ::bc::Hash* AssetDefinition::release_data() {
  // @@protoc_insertion_point(field_release:bc.AssetDefinition.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void AssetDefinition::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.AssetDefinition.data)
}

// -------------------------------------------------------------------

// ValueSource

// optional .bc.Hash ref = 1;
inline bool ValueSource::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void ValueSource::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::bc::Hash& ValueSource::ref() const {
  // @@protoc_insertion_point(field_get:bc.ValueSource.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::bc::Hash* ValueSource::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueSource.ref)
  return ref_;
}
inline ::bc::Hash* ValueSource::release_ref() {
  // @@protoc_insertion_point(field_release:bc.ValueSource.ref)
  
  ::bc::Hash* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void ValueSource::set_allocated_ref(::bc::Hash* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.ValueSource.ref)
}

// optional .bc.AssetAmount value = 2;
inline bool ValueSource::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ValueSource::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::bc::AssetAmount& ValueSource::value() const {
  // @@protoc_insertion_point(field_get:bc.ValueSource.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::bc::AssetAmount* ValueSource::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueSource.value)
  return value_;
}
inline ::bc::AssetAmount* ValueSource::release_value() {
  // @@protoc_insertion_point(field_release:bc.ValueSource.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ValueSource::set_allocated_value(::bc::AssetAmount* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.ValueSource.value)
}

// optional uint64 position = 3;
inline void ValueSource::clear_position() {
  position_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ValueSource::position() const {
  // @@protoc_insertion_point(field_get:bc.ValueSource.position)
  return position_;
}
inline void ValueSource::set_position(::google::protobuf::uint64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:bc.ValueSource.position)
}

// -------------------------------------------------------------------

// ValueDestination

// optional .bc.Hash ref = 1;
inline bool ValueDestination::has_ref() const {
  return !_is_default_instance_ && ref_ != NULL;
}
inline void ValueDestination::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) delete ref_;
  ref_ = NULL;
}
inline const ::bc::Hash& ValueDestination::ref() const {
  // @@protoc_insertion_point(field_get:bc.ValueDestination.ref)
  return ref_ != NULL ? *ref_ : *default_instance_->ref_;
}
inline ::bc::Hash* ValueDestination::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueDestination.ref)
  return ref_;
}
inline ::bc::Hash* ValueDestination::release_ref() {
  // @@protoc_insertion_point(field_release:bc.ValueDestination.ref)
  
  ::bc::Hash* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline void ValueDestination::set_allocated_ref(::bc::Hash* ref) {
  delete ref_;
  ref_ = ref;
  if (ref) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.ValueDestination.ref)
}

// optional .bc.AssetAmount value = 2;
inline bool ValueDestination::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ValueDestination::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::bc::AssetAmount& ValueDestination::value() const {
  // @@protoc_insertion_point(field_get:bc.ValueDestination.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::bc::AssetAmount* ValueDestination::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueDestination.value)
  return value_;
}
inline ::bc::AssetAmount* ValueDestination::release_value() {
  // @@protoc_insertion_point(field_release:bc.ValueDestination.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ValueDestination::set_allocated_value(::bc::AssetAmount* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.ValueDestination.value)
}

// optional uint64 position = 3;
inline void ValueDestination::clear_position() {
  position_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ValueDestination::position() const {
  // @@protoc_insertion_point(field_get:bc.ValueDestination.position)
  return position_;
}
inline void ValueDestination::set_position(::google::protobuf::uint64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:bc.ValueDestination.position)
}

// -------------------------------------------------------------------

// BlockHeader

// optional uint64 version = 1;
inline void BlockHeader::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::version() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.version)
  return version_;
}
inline void BlockHeader::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.version)
}

// optional uint64 serialized_size = 2;
inline void BlockHeader::clear_serialized_size() {
  serialized_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::serialized_size() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.serialized_size)
  return serialized_size_;
}
inline void BlockHeader::set_serialized_size(::google::protobuf::uint64 value) {
  
  serialized_size_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.serialized_size)
}

// optional uint64 height = 3;
inline void BlockHeader::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::height() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.height)
  return height_;
}
inline void BlockHeader::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.height)
}

// optional .bc.Hash previous_block_id = 4;
inline bool BlockHeader::has_previous_block_id() const {
  return !_is_default_instance_ && previous_block_id_ != NULL;
}
inline void BlockHeader::clear_previous_block_id() {
  if (GetArenaNoVirtual() == NULL && previous_block_id_ != NULL) delete previous_block_id_;
  previous_block_id_ = NULL;
}
inline const ::bc::Hash& BlockHeader::previous_block_id() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.previous_block_id)
  return previous_block_id_ != NULL ? *previous_block_id_ : *default_instance_->previous_block_id_;
}
inline ::bc::Hash* BlockHeader::mutable_previous_block_id() {
  
  if (previous_block_id_ == NULL) {
    previous_block_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.previous_block_id)
  return previous_block_id_;
}
inline ::bc::Hash* BlockHeader::release_previous_block_id() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.previous_block_id)
  
  ::bc::Hash* temp = previous_block_id_;
  previous_block_id_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_previous_block_id(::bc::Hash* previous_block_id) {
  delete previous_block_id_;
  previous_block_id_ = previous_block_id;
  if (previous_block_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.previous_block_id)
}

// optional .bc.Hash seed = 5;
inline bool BlockHeader::has_seed() const {
  return !_is_default_instance_ && seed_ != NULL;
}
inline void BlockHeader::clear_seed() {
  if (GetArenaNoVirtual() == NULL && seed_ != NULL) delete seed_;
  seed_ = NULL;
}
inline const ::bc::Hash& BlockHeader::seed() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.seed)
  return seed_ != NULL ? *seed_ : *default_instance_->seed_;
}
inline ::bc::Hash* BlockHeader::mutable_seed() {
  
  if (seed_ == NULL) {
    seed_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.seed)
  return seed_;
}
inline ::bc::Hash* BlockHeader::release_seed() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.seed)
  
  ::bc::Hash* temp = seed_;
  seed_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_seed(::bc::Hash* seed) {
  delete seed_;
  seed_ = seed;
  if (seed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.seed)
}

// optional uint64 timestamp = 6;
inline void BlockHeader::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.timestamp)
  return timestamp_;
}
inline void BlockHeader::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.timestamp)
}

// optional .bc.Hash transactions_root = 7;
inline bool BlockHeader::has_transactions_root() const {
  return !_is_default_instance_ && transactions_root_ != NULL;
}
inline void BlockHeader::clear_transactions_root() {
  if (GetArenaNoVirtual() == NULL && transactions_root_ != NULL) delete transactions_root_;
  transactions_root_ = NULL;
}
inline const ::bc::Hash& BlockHeader::transactions_root() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.transactions_root)
  return transactions_root_ != NULL ? *transactions_root_ : *default_instance_->transactions_root_;
}
inline ::bc::Hash* BlockHeader::mutable_transactions_root() {
  
  if (transactions_root_ == NULL) {
    transactions_root_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.transactions_root)
  return transactions_root_;
}
inline ::bc::Hash* BlockHeader::release_transactions_root() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.transactions_root)
  
  ::bc::Hash* temp = transactions_root_;
  transactions_root_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_transactions_root(::bc::Hash* transactions_root) {
  delete transactions_root_;
  transactions_root_ = transactions_root;
  if (transactions_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.transactions_root)
}

// optional .bc.Hash assets_root = 8;
inline bool BlockHeader::has_assets_root() const {
  return !_is_default_instance_ && assets_root_ != NULL;
}
inline void BlockHeader::clear_assets_root() {
  if (GetArenaNoVirtual() == NULL && assets_root_ != NULL) delete assets_root_;
  assets_root_ = NULL;
}
inline const ::bc::Hash& BlockHeader::assets_root() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.assets_root)
  return assets_root_ != NULL ? *assets_root_ : *default_instance_->assets_root_;
}
inline ::bc::Hash* BlockHeader::mutable_assets_root() {
  
  if (assets_root_ == NULL) {
    assets_root_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.assets_root)
  return assets_root_;
}
inline ::bc::Hash* BlockHeader::release_assets_root() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.assets_root)
  
  ::bc::Hash* temp = assets_root_;
  assets_root_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_assets_root(::bc::Hash* assets_root) {
  delete assets_root_;
  assets_root_ = assets_root;
  if (assets_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.assets_root)
}

// optional .bc.TransactionStatus transaction_status = 9;
inline bool BlockHeader::has_transaction_status() const {
  return !_is_default_instance_ && transaction_status_ != NULL;
}
inline void BlockHeader::clear_transaction_status() {
  if (GetArenaNoVirtual() == NULL && transaction_status_ != NULL) delete transaction_status_;
  transaction_status_ = NULL;
}
inline const ::bc::TransactionStatus& BlockHeader::transaction_status() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.transaction_status)
  return transaction_status_ != NULL ? *transaction_status_ : *default_instance_->transaction_status_;
}
inline ::bc::TransactionStatus* BlockHeader::mutable_transaction_status() {
  
  if (transaction_status_ == NULL) {
    transaction_status_ = new ::bc::TransactionStatus;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.transaction_status)
  return transaction_status_;
}
inline ::bc::TransactionStatus* BlockHeader::release_transaction_status() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.transaction_status)
  
  ::bc::TransactionStatus* temp = transaction_status_;
  transaction_status_ = NULL;
  return temp;
}
inline void BlockHeader::set_allocated_transaction_status(::bc::TransactionStatus* transaction_status) {
  delete transaction_status_;
  transaction_status_ = transaction_status;
  if (transaction_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.transaction_status)
}

// optional uint64 nonce = 10;
inline void BlockHeader::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::nonce() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.nonce)
  return nonce_;
}
inline void BlockHeader::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.nonce)
}

// optional uint64 bits = 11;
inline void BlockHeader::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::bits() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.bits)
  return bits_;
}
inline void BlockHeader::set_bits(::google::protobuf::uint64 value) {
  
  bits_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.bits)
}

// -------------------------------------------------------------------

// TxHeader

// optional uint64 version = 1;
inline void TxHeader::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::version() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.version)
  return version_;
}
inline void TxHeader::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.version)
}

// optional uint64 serialized_size = 2;
inline void TxHeader::clear_serialized_size() {
  serialized_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::serialized_size() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.serialized_size)
  return serialized_size_;
}
inline void TxHeader::set_serialized_size(::google::protobuf::uint64 value) {
  
  serialized_size_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.serialized_size)
}

// optional uint64 time_range = 3;
inline void TxHeader::clear_time_range() {
  time_range_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::time_range() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.time_range)
  return time_range_;
}
inline void TxHeader::set_time_range(::google::protobuf::uint64 value) {
  
  time_range_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.time_range)
}

// repeated .bc.Hash result_ids = 4;
inline int TxHeader::result_ids_size() const {
  return result_ids_.size();
}
inline void TxHeader::clear_result_ids() {
  result_ids_.Clear();
}
inline const ::bc::Hash& TxHeader::result_ids(int index) const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.result_ids)
  return result_ids_.Get(index);
}
inline ::bc::Hash* TxHeader::mutable_result_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bc.TxHeader.result_ids)
  return result_ids_.Mutable(index);
}
inline ::bc::Hash* TxHeader::add_result_ids() {
  // @@protoc_insertion_point(field_add:bc.TxHeader.result_ids)
  return result_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::Hash >*
TxHeader::mutable_result_ids() {
  // @@protoc_insertion_point(field_mutable_list:bc.TxHeader.result_ids)
  return &result_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::Hash >&
TxHeader::result_ids() const {
  // @@protoc_insertion_point(field_list:bc.TxHeader.result_ids)
  return result_ids_;
}

// optional .bc.Hash data = 5;
inline bool TxHeader::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void TxHeader::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& TxHeader::data() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* TxHeader::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.TxHeader.data)
  return data_;
}
inline ::bc::Hash* TxHeader::release_data() {
  // @@protoc_insertion_point(field_release:bc.TxHeader.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void TxHeader::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.TxHeader.data)
}

// optional .bc.Hash ext_hash = 6;
inline bool TxHeader::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void TxHeader::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& TxHeader::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* TxHeader::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.TxHeader.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* TxHeader::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.TxHeader.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void TxHeader::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.TxHeader.ext_hash)
}

// -------------------------------------------------------------------

// TransactionStatus

// optional bytes bitmap = 1;
inline void TransactionStatus::clear_bitmap() {
  bitmap_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionStatus::bitmap() const {
  // @@protoc_insertion_point(field_get:bc.TransactionStatus.bitmap)
  return bitmap_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionStatus::set_bitmap(const ::std::string& value) {
  
  bitmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bc.TransactionStatus.bitmap)
}
inline void TransactionStatus::set_bitmap(const char* value) {
  
  bitmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bc.TransactionStatus.bitmap)
}
inline void TransactionStatus::set_bitmap(const void* value, size_t size) {
  
  bitmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bc.TransactionStatus.bitmap)
}
inline ::std::string* TransactionStatus::mutable_bitmap() {
  
  // @@protoc_insertion_point(field_mutable:bc.TransactionStatus.bitmap)
  return bitmap_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionStatus::release_bitmap() {
  // @@protoc_insertion_point(field_release:bc.TransactionStatus.bitmap)
  
  return bitmap_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionStatus::set_allocated_bitmap(::std::string* bitmap) {
  if (bitmap != NULL) {
    
  } else {
    
  }
  bitmap_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bitmap);
  // @@protoc_insertion_point(field_set_allocated:bc.TransactionStatus.bitmap)
}

// -------------------------------------------------------------------

// Mux

// repeated .bc.ValueSource sources = 1;
inline int Mux::sources_size() const {
  return sources_.size();
}
inline void Mux::clear_sources() {
  sources_.Clear();
}
inline const ::bc::ValueSource& Mux::sources(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.sources)
  return sources_.Get(index);
}
inline ::bc::ValueSource* Mux::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.sources)
  return sources_.Mutable(index);
}
inline ::bc::ValueSource* Mux::add_sources() {
  // @@protoc_insertion_point(field_add:bc.Mux.sources)
  return sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >*
Mux::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.sources)
  return &sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >&
Mux::sources() const {
  // @@protoc_insertion_point(field_list:bc.Mux.sources)
  return sources_;
}

// optional .bc.Program program = 2;
inline bool Mux::has_program() const {
  return !_is_default_instance_ && program_ != NULL;
}
inline void Mux::clear_program() {
  if (GetArenaNoVirtual() == NULL && program_ != NULL) delete program_;
  program_ = NULL;
}
inline const ::bc::Program& Mux::program() const {
  // @@protoc_insertion_point(field_get:bc.Mux.program)
  return program_ != NULL ? *program_ : *default_instance_->program_;
}
inline ::bc::Program* Mux::mutable_program() {
  
  if (program_ == NULL) {
    program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.Mux.program)
  return program_;
}
inline ::bc::Program* Mux::release_program() {
  // @@protoc_insertion_point(field_release:bc.Mux.program)
  
  ::bc::Program* temp = program_;
  program_ = NULL;
  return temp;
}
inline void Mux::set_allocated_program(::bc::Program* program) {
  delete program_;
  program_ = program;
  if (program) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Mux.program)
}

// optional .bc.Hash ext_hash = 3;
inline bool Mux::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Mux::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Mux::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Mux.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Mux::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Mux.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Mux::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Mux.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Mux::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Mux.ext_hash)
}

// repeated .bc.ValueDestination witness_destinations = 4;
inline int Mux::witness_destinations_size() const {
  return witness_destinations_.size();
}
inline void Mux::clear_witness_destinations() {
  witness_destinations_.Clear();
}
inline const ::bc::ValueDestination& Mux::witness_destinations(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.witness_destinations)
  return witness_destinations_.Get(index);
}
inline ::bc::ValueDestination* Mux::mutable_witness_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.witness_destinations)
  return witness_destinations_.Mutable(index);
}
inline ::bc::ValueDestination* Mux::add_witness_destinations() {
  // @@protoc_insertion_point(field_add:bc.Mux.witness_destinations)
  return witness_destinations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >*
Mux::mutable_witness_destinations() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.witness_destinations)
  return &witness_destinations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >&
Mux::witness_destinations() const {
  // @@protoc_insertion_point(field_list:bc.Mux.witness_destinations)
  return witness_destinations_;
}

// repeated bytes witness_arguments = 5;
inline int Mux::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Mux::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Mux::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Mux::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Mux::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Mux.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
inline void Mux::set_witness_arguments(int index, const char* value) {
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Mux.witness_arguments)
}
inline void Mux::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Mux.witness_arguments)
}
inline ::std::string* Mux::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Mux.witness_arguments)
  return witness_arguments_.Add();
}
inline void Mux::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Mux.witness_arguments)
}
inline void Mux::add_witness_arguments(const char* value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Mux.witness_arguments)
}
inline void Mux::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Mux.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mux::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Mux.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mux::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.witness_arguments)
  return &witness_arguments_;
}

// -------------------------------------------------------------------

// Nonce

// optional .bc.Program program = 1;
inline bool Nonce::has_program() const {
  return !_is_default_instance_ && program_ != NULL;
}
inline void Nonce::clear_program() {
  if (GetArenaNoVirtual() == NULL && program_ != NULL) delete program_;
  program_ = NULL;
}
inline const ::bc::Program& Nonce::program() const {
  // @@protoc_insertion_point(field_get:bc.Nonce.program)
  return program_ != NULL ? *program_ : *default_instance_->program_;
}
inline ::bc::Program* Nonce::mutable_program() {
  
  if (program_ == NULL) {
    program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.Nonce.program)
  return program_;
}
inline ::bc::Program* Nonce::release_program() {
  // @@protoc_insertion_point(field_release:bc.Nonce.program)
  
  ::bc::Program* temp = program_;
  program_ = NULL;
  return temp;
}
inline void Nonce::set_allocated_program(::bc::Program* program) {
  delete program_;
  program_ = program;
  if (program) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Nonce.program)
}

// optional .bc.Hash ext_hash = 2;
inline bool Nonce::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Nonce::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Nonce::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Nonce.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Nonce::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Nonce.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Nonce::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Nonce.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Nonce::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Nonce.ext_hash)
}

// repeated bytes witness_arguments = 3;
inline int Nonce::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Nonce::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Nonce::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Nonce.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Nonce::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Nonce.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Nonce::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Nonce.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
inline void Nonce::set_witness_arguments(int index, const char* value) {
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Nonce.witness_arguments)
}
inline void Nonce::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Nonce.witness_arguments)
}
inline ::std::string* Nonce::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Nonce.witness_arguments)
  return witness_arguments_.Add();
}
inline void Nonce::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Nonce.witness_arguments)
}
inline void Nonce::add_witness_arguments(const char* value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Nonce.witness_arguments)
}
inline void Nonce::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Nonce.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Nonce::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Nonce.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Nonce::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Nonce.witness_arguments)
  return &witness_arguments_;
}

// optional .bc.Hash witness_anchored_id = 4;
inline bool Nonce::has_witness_anchored_id() const {
  return !_is_default_instance_ && witness_anchored_id_ != NULL;
}
inline void Nonce::clear_witness_anchored_id() {
  if (GetArenaNoVirtual() == NULL && witness_anchored_id_ != NULL) delete witness_anchored_id_;
  witness_anchored_id_ = NULL;
}
inline const ::bc::Hash& Nonce::witness_anchored_id() const {
  // @@protoc_insertion_point(field_get:bc.Nonce.witness_anchored_id)
  return witness_anchored_id_ != NULL ? *witness_anchored_id_ : *default_instance_->witness_anchored_id_;
}
inline ::bc::Hash* Nonce::mutable_witness_anchored_id() {
  
  if (witness_anchored_id_ == NULL) {
    witness_anchored_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Nonce.witness_anchored_id)
  return witness_anchored_id_;
}
inline ::bc::Hash* Nonce::release_witness_anchored_id() {
  // @@protoc_insertion_point(field_release:bc.Nonce.witness_anchored_id)
  
  ::bc::Hash* temp = witness_anchored_id_;
  witness_anchored_id_ = NULL;
  return temp;
}
inline void Nonce::set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id) {
  delete witness_anchored_id_;
  witness_anchored_id_ = witness_anchored_id;
  if (witness_anchored_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Nonce.witness_anchored_id)
}

// -------------------------------------------------------------------

// Coinbase

// optional .bc.ValueDestination witness_destination = 1;
inline bool Coinbase::has_witness_destination() const {
  return !_is_default_instance_ && witness_destination_ != NULL;
}
inline void Coinbase::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) delete witness_destination_;
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Coinbase::witness_destination() const {
  // @@protoc_insertion_point(field_get:bc.Coinbase.witness_destination)
  return witness_destination_ != NULL ? *witness_destination_ : *default_instance_->witness_destination_;
}
inline ::bc::ValueDestination* Coinbase::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Coinbase.witness_destination)
  return witness_destination_;
}
inline ::bc::ValueDestination* Coinbase::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Coinbase.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline void Coinbase::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  delete witness_destination_;
  witness_destination_ = witness_destination;
  if (witness_destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Coinbase.witness_destination)
}

// optional bytes arbitrary = 2;
inline void Coinbase::clear_arbitrary() {
  arbitrary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Coinbase::arbitrary() const {
  // @@protoc_insertion_point(field_get:bc.Coinbase.arbitrary)
  return arbitrary_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coinbase::set_arbitrary(const ::std::string& value) {
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bc.Coinbase.arbitrary)
}
inline void Coinbase::set_arbitrary(const char* value) {
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bc.Coinbase.arbitrary)
}
inline void Coinbase::set_arbitrary(const void* value, size_t size) {
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bc.Coinbase.arbitrary)
}
inline ::std::string* Coinbase::mutable_arbitrary() {
  
  // @@protoc_insertion_point(field_mutable:bc.Coinbase.arbitrary)
  return arbitrary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coinbase::release_arbitrary() {
  // @@protoc_insertion_point(field_release:bc.Coinbase.arbitrary)
  
  return arbitrary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coinbase::set_allocated_arbitrary(::std::string* arbitrary) {
  if (arbitrary != NULL) {
    
  } else {
    
  }
  arbitrary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arbitrary);
  // @@protoc_insertion_point(field_set_allocated:bc.Coinbase.arbitrary)
}

// -------------------------------------------------------------------

// Output

// optional .bc.ValueSource source = 1;
inline bool Output::has_source() const {
  return !_is_default_instance_ && source_ != NULL;
}
inline void Output::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) delete source_;
  source_ = NULL;
}
inline const ::bc::ValueSource& Output::source() const {
  // @@protoc_insertion_point(field_get:bc.Output.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::bc::ValueSource* Output::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::bc::ValueSource;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.source)
  return source_;
}
inline ::bc::ValueSource* Output::release_source() {
  // @@protoc_insertion_point(field_release:bc.Output.source)
  
  ::bc::ValueSource* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Output::set_allocated_source(::bc::ValueSource* source) {
  delete source_;
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Output.source)
}

// optional .bc.Program control_program = 2;
inline bool Output::has_control_program() const {
  return !_is_default_instance_ && control_program_ != NULL;
}
inline void Output::clear_control_program() {
  if (GetArenaNoVirtual() == NULL && control_program_ != NULL) delete control_program_;
  control_program_ = NULL;
}
inline const ::bc::Program& Output::control_program() const {
  // @@protoc_insertion_point(field_get:bc.Output.control_program)
  return control_program_ != NULL ? *control_program_ : *default_instance_->control_program_;
}
inline ::bc::Program* Output::mutable_control_program() {
  
  if (control_program_ == NULL) {
    control_program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.control_program)
  return control_program_;
}
inline ::bc::Program* Output::release_control_program() {
  // @@protoc_insertion_point(field_release:bc.Output.control_program)
  
  ::bc::Program* temp = control_program_;
  control_program_ = NULL;
  return temp;
}
inline void Output::set_allocated_control_program(::bc::Program* control_program) {
  delete control_program_;
  control_program_ = control_program;
  if (control_program) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Output.control_program)
}

// optional .bc.Hash data = 3;
inline bool Output::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void Output::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& Output::data() const {
  // @@protoc_insertion_point(field_get:bc.Output.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* Output::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.data)
  return data_;
}
inline ::bc::Hash* Output::release_data() {
  // @@protoc_insertion_point(field_release:bc.Output.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Output::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Output.data)
}

// optional .bc.Hash ext_hash = 4;
inline bool Output::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Output::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Output::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Output.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Output::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Output::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Output.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Output::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Output.ext_hash)
}

// optional uint64 ordinal = 5;
inline void Output::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Output::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Output.ordinal)
  return ordinal_;
}
inline void Output::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Output.ordinal)
}

// -------------------------------------------------------------------

// Retirement

// optional .bc.ValueSource source = 1;
inline bool Retirement::has_source() const {
  return !_is_default_instance_ && source_ != NULL;
}
inline void Retirement::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) delete source_;
  source_ = NULL;
}
inline const ::bc::ValueSource& Retirement::source() const {
  // @@protoc_insertion_point(field_get:bc.Retirement.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::bc::ValueSource* Retirement::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::bc::ValueSource;
  }
  // @@protoc_insertion_point(field_mutable:bc.Retirement.source)
  return source_;
}
inline ::bc::ValueSource* Retirement::release_source() {
  // @@protoc_insertion_point(field_release:bc.Retirement.source)
  
  ::bc::ValueSource* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Retirement::set_allocated_source(::bc::ValueSource* source) {
  delete source_;
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Retirement.source)
}

// optional .bc.Hash data = 2;
inline bool Retirement::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void Retirement::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& Retirement::data() const {
  // @@protoc_insertion_point(field_get:bc.Retirement.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* Retirement::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Retirement.data)
  return data_;
}
inline ::bc::Hash* Retirement::release_data() {
  // @@protoc_insertion_point(field_release:bc.Retirement.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Retirement::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Retirement.data)
}

// optional .bc.Hash ext_hash = 3;
inline bool Retirement::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Retirement::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Retirement::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Retirement.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Retirement::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Retirement.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Retirement::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Retirement.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Retirement::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Retirement.ext_hash)
}

// optional uint64 ordinal = 4;
inline void Retirement::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Retirement::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Retirement.ordinal)
  return ordinal_;
}
inline void Retirement::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Retirement.ordinal)
}

// -------------------------------------------------------------------

// Issuance

// optional .bc.Hash anchor_id = 1;
inline bool Issuance::has_anchor_id() const {
  return !_is_default_instance_ && anchor_id_ != NULL;
}
inline void Issuance::clear_anchor_id() {
  if (GetArenaNoVirtual() == NULL && anchor_id_ != NULL) delete anchor_id_;
  anchor_id_ = NULL;
}
inline const ::bc::Hash& Issuance::anchor_id() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.anchor_id)
  return anchor_id_ != NULL ? *anchor_id_ : *default_instance_->anchor_id_;
}
inline ::bc::Hash* Issuance::mutable_anchor_id() {
  
  if (anchor_id_ == NULL) {
    anchor_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.anchor_id)
  return anchor_id_;
}
inline ::bc::Hash* Issuance::release_anchor_id() {
  // @@protoc_insertion_point(field_release:bc.Issuance.anchor_id)
  
  ::bc::Hash* temp = anchor_id_;
  anchor_id_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_anchor_id(::bc::Hash* anchor_id) {
  delete anchor_id_;
  anchor_id_ = anchor_id;
  if (anchor_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.anchor_id)
}

// optional .bc.AssetAmount value = 2;
inline bool Issuance::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void Issuance::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::bc::AssetAmount& Issuance::value() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::bc::AssetAmount* Issuance::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.value)
  return value_;
}
inline ::bc::AssetAmount* Issuance::release_value() {
  // @@protoc_insertion_point(field_release:bc.Issuance.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_value(::bc::AssetAmount* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.value)
}

// optional .bc.Hash data = 3;
inline bool Issuance::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void Issuance::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& Issuance::data() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* Issuance::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.data)
  return data_;
}
inline ::bc::Hash* Issuance::release_data() {
  // @@protoc_insertion_point(field_release:bc.Issuance.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.data)
}

// optional .bc.Hash ext_hash = 4;
inline bool Issuance::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Issuance::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Issuance::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Issuance::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Issuance::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Issuance.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.ext_hash)
}

// optional .bc.ValueDestination witness_destination = 5;
inline bool Issuance::has_witness_destination() const {
  return !_is_default_instance_ && witness_destination_ != NULL;
}
inline void Issuance::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) delete witness_destination_;
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Issuance::witness_destination() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_destination)
  return witness_destination_ != NULL ? *witness_destination_ : *default_instance_->witness_destination_;
}
inline ::bc::ValueDestination* Issuance::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_destination)
  return witness_destination_;
}
inline ::bc::ValueDestination* Issuance::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Issuance.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  delete witness_destination_;
  witness_destination_ = witness_destination;
  if (witness_destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.witness_destination)
}

// optional .bc.AssetDefinition witness_asset_definition = 6;
inline bool Issuance::has_witness_asset_definition() const {
  return !_is_default_instance_ && witness_asset_definition_ != NULL;
}
inline void Issuance::clear_witness_asset_definition() {
  if (GetArenaNoVirtual() == NULL && witness_asset_definition_ != NULL) delete witness_asset_definition_;
  witness_asset_definition_ = NULL;
}
inline const ::bc::AssetDefinition& Issuance::witness_asset_definition() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_asset_definition)
  return witness_asset_definition_ != NULL ? *witness_asset_definition_ : *default_instance_->witness_asset_definition_;
}
inline ::bc::AssetDefinition* Issuance::mutable_witness_asset_definition() {
  
  if (witness_asset_definition_ == NULL) {
    witness_asset_definition_ = new ::bc::AssetDefinition;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_asset_definition)
  return witness_asset_definition_;
}
inline ::bc::AssetDefinition* Issuance::release_witness_asset_definition() {
  // @@protoc_insertion_point(field_release:bc.Issuance.witness_asset_definition)
  
  ::bc::AssetDefinition* temp = witness_asset_definition_;
  witness_asset_definition_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_witness_asset_definition(::bc::AssetDefinition* witness_asset_definition) {
  delete witness_asset_definition_;
  witness_asset_definition_ = witness_asset_definition;
  if (witness_asset_definition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.witness_asset_definition)
}

// repeated bytes witness_arguments = 7;
inline int Issuance::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Issuance::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Issuance::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Issuance::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Issuance::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Issuance.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
inline void Issuance::set_witness_arguments(int index, const char* value) {
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Issuance.witness_arguments)
}
inline void Issuance::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Issuance.witness_arguments)
}
inline ::std::string* Issuance::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Issuance.witness_arguments)
  return witness_arguments_.Add();
}
inline void Issuance::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Issuance.witness_arguments)
}
inline void Issuance::add_witness_arguments(const char* value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Issuance.witness_arguments)
}
inline void Issuance::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Issuance.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Issuance::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Issuance.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Issuance::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Issuance.witness_arguments)
  return &witness_arguments_;
}

// optional .bc.Hash witness_anchored_id = 8;
inline bool Issuance::has_witness_anchored_id() const {
  return !_is_default_instance_ && witness_anchored_id_ != NULL;
}
inline void Issuance::clear_witness_anchored_id() {
  if (GetArenaNoVirtual() == NULL && witness_anchored_id_ != NULL) delete witness_anchored_id_;
  witness_anchored_id_ = NULL;
}
inline const ::bc::Hash& Issuance::witness_anchored_id() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_anchored_id)
  return witness_anchored_id_ != NULL ? *witness_anchored_id_ : *default_instance_->witness_anchored_id_;
}
inline ::bc::Hash* Issuance::mutable_witness_anchored_id() {
  
  if (witness_anchored_id_ == NULL) {
    witness_anchored_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_anchored_id)
  return witness_anchored_id_;
}
inline ::bc::Hash* Issuance::release_witness_anchored_id() {
  // @@protoc_insertion_point(field_release:bc.Issuance.witness_anchored_id)
  
  ::bc::Hash* temp = witness_anchored_id_;
  witness_anchored_id_ = NULL;
  return temp;
}
inline void Issuance::set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id) {
  delete witness_anchored_id_;
  witness_anchored_id_ = witness_anchored_id;
  if (witness_anchored_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.witness_anchored_id)
}

// optional uint64 ordinal = 9;
inline void Issuance::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Issuance::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.ordinal)
  return ordinal_;
}
inline void Issuance::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Issuance.ordinal)
}

// -------------------------------------------------------------------

// Spend

// optional .bc.Hash spent_output_id = 1;
inline bool Spend::has_spent_output_id() const {
  return !_is_default_instance_ && spent_output_id_ != NULL;
}
inline void Spend::clear_spent_output_id() {
  if (GetArenaNoVirtual() == NULL && spent_output_id_ != NULL) delete spent_output_id_;
  spent_output_id_ = NULL;
}
inline const ::bc::Hash& Spend::spent_output_id() const {
  // @@protoc_insertion_point(field_get:bc.Spend.spent_output_id)
  return spent_output_id_ != NULL ? *spent_output_id_ : *default_instance_->spent_output_id_;
}
inline ::bc::Hash* Spend::mutable_spent_output_id() {
  
  if (spent_output_id_ == NULL) {
    spent_output_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.spent_output_id)
  return spent_output_id_;
}
inline ::bc::Hash* Spend::release_spent_output_id() {
  // @@protoc_insertion_point(field_release:bc.Spend.spent_output_id)
  
  ::bc::Hash* temp = spent_output_id_;
  spent_output_id_ = NULL;
  return temp;
}
inline void Spend::set_allocated_spent_output_id(::bc::Hash* spent_output_id) {
  delete spent_output_id_;
  spent_output_id_ = spent_output_id;
  if (spent_output_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.spent_output_id)
}

// optional .bc.Hash data = 2;
inline bool Spend::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void Spend::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::bc::Hash& Spend::data() const {
  // @@protoc_insertion_point(field_get:bc.Spend.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::bc::Hash* Spend::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.data)
  return data_;
}
inline ::bc::Hash* Spend::release_data() {
  // @@protoc_insertion_point(field_release:bc.Spend.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Spend::set_allocated_data(::bc::Hash* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.data)
}

// optional .bc.Hash ext_hash = 3;
inline bool Spend::has_ext_hash() const {
  return !_is_default_instance_ && ext_hash_ != NULL;
}
inline void Spend::clear_ext_hash() {
  if (GetArenaNoVirtual() == NULL && ext_hash_ != NULL) delete ext_hash_;
  ext_hash_ = NULL;
}
inline const ::bc::Hash& Spend::ext_hash() const {
  // @@protoc_insertion_point(field_get:bc.Spend.ext_hash)
  return ext_hash_ != NULL ? *ext_hash_ : *default_instance_->ext_hash_;
}
inline ::bc::Hash* Spend::mutable_ext_hash() {
  
  if (ext_hash_ == NULL) {
    ext_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.ext_hash)
  return ext_hash_;
}
inline ::bc::Hash* Spend::release_ext_hash() {
  // @@protoc_insertion_point(field_release:bc.Spend.ext_hash)
  
  ::bc::Hash* temp = ext_hash_;
  ext_hash_ = NULL;
  return temp;
}
inline void Spend::set_allocated_ext_hash(::bc::Hash* ext_hash) {
  delete ext_hash_;
  ext_hash_ = ext_hash;
  if (ext_hash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.ext_hash)
}

// optional .bc.ValueDestination witness_destination = 4;
inline bool Spend::has_witness_destination() const {
  return !_is_default_instance_ && witness_destination_ != NULL;
}
inline void Spend::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) delete witness_destination_;
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Spend::witness_destination() const {
  // @@protoc_insertion_point(field_get:bc.Spend.witness_destination)
  return witness_destination_ != NULL ? *witness_destination_ : *default_instance_->witness_destination_;
}
inline ::bc::ValueDestination* Spend::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.witness_destination)
  return witness_destination_;
}
inline ::bc::ValueDestination* Spend::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Spend.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline void Spend::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  delete witness_destination_;
  witness_destination_ = witness_destination;
  if (witness_destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.witness_destination)
}

// repeated bytes witness_arguments = 5;
inline int Spend::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Spend::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Spend::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Spend.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Spend::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Spend.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Spend::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Spend.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
inline void Spend::set_witness_arguments(int index, const char* value) {
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Spend.witness_arguments)
}
inline void Spend::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Spend.witness_arguments)
}
inline ::std::string* Spend::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Spend.witness_arguments)
  return witness_arguments_.Add();
}
inline void Spend::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Spend.witness_arguments)
}
inline void Spend::add_witness_arguments(const char* value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Spend.witness_arguments)
}
inline void Spend::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Spend.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Spend::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Spend.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Spend::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Spend.witness_arguments)
  return &witness_arguments_;
}

// optional .bc.Hash witness_anchored_id = 6;
inline bool Spend::has_witness_anchored_id() const {
  return !_is_default_instance_ && witness_anchored_id_ != NULL;
}
inline void Spend::clear_witness_anchored_id() {
  if (GetArenaNoVirtual() == NULL && witness_anchored_id_ != NULL) delete witness_anchored_id_;
  witness_anchored_id_ = NULL;
}
inline const ::bc::Hash& Spend::witness_anchored_id() const {
  // @@protoc_insertion_point(field_get:bc.Spend.witness_anchored_id)
  return witness_anchored_id_ != NULL ? *witness_anchored_id_ : *default_instance_->witness_anchored_id_;
}
inline ::bc::Hash* Spend::mutable_witness_anchored_id() {
  
  if (witness_anchored_id_ == NULL) {
    witness_anchored_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.witness_anchored_id)
  return witness_anchored_id_;
}
inline ::bc::Hash* Spend::release_witness_anchored_id() {
  // @@protoc_insertion_point(field_release:bc.Spend.witness_anchored_id)
  
  ::bc::Hash* temp = witness_anchored_id_;
  witness_anchored_id_ = NULL;
  return temp;
}
inline void Spend::set_allocated_witness_anchored_id(::bc::Hash* witness_anchored_id) {
  delete witness_anchored_id_;
  witness_anchored_id_ = witness_anchored_id;
  if (witness_anchored_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.witness_anchored_id)
}

// optional uint64 ordinal = 7;
inline void Spend::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Spend::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Spend.ordinal)
  return ordinal_;
}
inline void Spend::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Spend.ordinal)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bc_2eproto__INCLUDED
